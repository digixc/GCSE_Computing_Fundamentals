#+STARTUP:indent
#+HTML_HEAD: <link rel="stylesheet" type="text/css" href="css/styles.css"/>
#+HTML_HEAD_EXTRA: <link href='http://fonts.googleapis.com/css?family=Ubuntu+Mono|Ubuntu' rel='stylesheet' type='text/css'>
#+OPTIONS: f:nil author:nil num:1 creator:nil timestamp:nil 
#+TITLE: 3.1.4 Sorting Algorithms
#+AUTHOR: Stephen Fone

#+BEGIN_HTML
<div class=ribbon>
<a href="https://github.com/">Fork me on GitHub</a>
</div>
#+END_HTML

* COMMENT Use as a template
:PROPERTIES:
:HTML_CONTAINER_CLASS: activity
:END:
** Learn It
:PROPERTIES:
:HTML_CONTAINER_CLASS: learn
:END:

** Research It
:PROPERTIES:
:HTML_CONTAINER_CLASS: research
:END:

** Design It
:PROPERTIES:
:HTML_CONTAINER_CLASS: design
:END:

** Build It
:PROPERTIES:
:HTML_CONTAINER_CLASS: build
:END:

** Test It
:PROPERTIES:
:HTML_CONTAINER_CLASS: test
:END:

** Run It
:PROPERTIES:
:HTML_CONTAINER_CLASS: run
:END:

** Document It
:PROPERTIES:
:HTML_CONTAINER_CLASS: document
:END:

** Code It
:PROPERTIES:
:HTML_CONTAINER_CLASS: code
:END:

** Program It
:PROPERTIES:
:HTML_CONTAINER_CLASS: program
:END:

** Try It
:PROPERTIES:
:HTML_CONTAINER_CLASS: try
:END:

** Badge It
:PROPERTIES:
:HTML_CONTAINER_CLASS: badge
:END:

** Save It
:PROPERTIES:
:HTML_CONTAINER_CLASS: save
:END:


* Sorting Algorithms
:PROPERTIES:
:HTML_CONTAINER_CLASS: activity
:END:
** Learn It: What are Sorting Algorithms?
:PROPERTIES:
:HTML_CONTAINER_CLASS: learn
:END:
#+BEGIN_SRC
Sorting Algorithms are used to arrange data within a list into a defined order.
Whether that be numerical order, alphabetical order or chronological order,
ascending (A-Z) or descending (Z-A).
#+END_SRC
- When sorting data items it is essential to =compare= them with each
  other, so that they can be =put= into the =correct order=.
- There may be millions of items of data to compare, so sorting
  algorithms must carry out the task as efficiently as possible, so
  as not to cause a =bottleneck= (/Another part of the program may not
  be able to run until the sorting has been carried out/).

[[file:img/sorting1.png]]

- Searching and Sorting Algorithms are used in lots of programs to
  make =data easier= to =access= and =understand=.
- Computer game leader boards are =sorted= from the /highest/ score to the
  /lowest/ score to make it easy to find the winner and your position
  in the list.
 
#+BEGIN_SRC
Key Term - Compare: Assess how items of data are similar or different to each
other, to help decide which order they should go in.
#+END_SRC
#+BEGIN_SRC
Key Term - Adjacent Items: Items of data that are next to each other.
#+END_SRC

- In the last topic we learned about searching algorithms and how they
  are used to search for data.
- In this topic we will look at sorting algorithms, there are many
  different sorting algorithms, but we will only be looking at two of
  them:
 1. Bubble Sort.
 2. Merge Sort.

* Bubble Sort Algorithm
:PROPERTIES:
:HTML_CONTAINER_CLASS: activity
:END:
** Learn It: What is a Bubble Sort?
:PROPERTIES:
:HTML_CONTAINER_CLASS: learn
:END:
#+BEGIN_SRC
Bubble Sort - A bubble sort works by repeatedly going through the list to be
sorted comparing each pair of adjacent elements.
If the elements are in the wrong order they are swapped, if not, move on to
the next pair.
#+END_SRC
[[file:img/bubble_sort_ani.gif]]
*Bubble Sort Explained*
[[file:img/bubble_sort_pass.png]]
- *Step 1:* Compare the first two items in the list. If they are in
  the correct order, leave them. If items are not in the correct
  order, swap them. In the example above '5' is larger than '1', so
  they need to be swapped.
- *Step 2:* Repeat the step 1 process for items '2' and '3' in the list. In the
  example above '5' is smaller than '6', so they do not need to be
  swapped.
- *Step 3:* Continue applying the step 1 process to the rest of the
  items in the list.
- Once one pass is completed, repeat the process again and again until
  no swaps are required and all the numbers are in the correct order.
- A Bubble Sort is likely to require muliple passes through the list,
  so it can be inefficient and unsuitable for larger files.
#+BEGIN_HTML
<br>
#+END_HTML
*Bubble Sort Algorithm Video*
#+BEGIN_HTML
<iframe width="560" height="315" src="https://www.youtube.com/embed/V-XP4gqxFZI" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe>
#+END_HTML

*Algorithm for a Bubble Sort*
- In this algorithm, =number= is in a =list= holding nine numbers.
- Each =element= of the list is referred to using an =index= in square
  brackets.
- In the list below, the first element of the list is '6' and is at
  =index position [0]=, and the last element of the list is '19' and
  is at =index position [8]=.

[[file:img/bubble_sort_algor.png]]
- We use the flag variable to set /False/ at the beginning of each
  pass. As soon as a swap is made, the flag is set to /True/.
- If a pass is completed without any swaps being made, the flag
  remains /Flase/ and the /WHILE/ loop ends. The sort is complete.

** Badge It: Bubble Sort Algorithm
:PROPERTIES:
:HTML_CONTAINER_CLASS: badge
:END:

*Silver*: Complete the Bubble Sort Algorithm shown in the Trinket
window below:

#+BEGIN_HTML
<iframe src="https://trinket.io/embed/python/6b4ccdc6e4" width="100%" height="600" frameborder="0" marginwidth="0" marginheight="0" allowfullscreen></iframe>
#+END_HTML

- /Upload to Algorithms - Sorting Algorithms: Silver on BourneToLearn/

* Merge Sort Algorithm
:PROPERTIES:
:HTML_CONTAINER_CLASS: activity
:END:
** Learn It: What is a Merge Sort?
:PROPERTIES:
:HTML_CONTAINER_CLASS: learn
:END:
#+BEGIN_SRC
Merge Sort - Is a 'Divide and Conquer' algorithm that splits a list into decrete
elements and then merges the elements back together in order.
A merge sort is quicker and more efficient than a bubble sort when using longer
lists. However, it uses more memory and can take longer to sort shorter lists.
#+END_SRC
[[file:img/merge_sort_ani.gif]]
*Merge Sort Explained*
[[file:img/Merge_sort2.png]]
- *Step 1:* Split the list in half to create two subsets.
- *Step 2:* Continue to split the subsets in half, until only
  individual items remain.
- *Step 3:* Merge individual items back together in pairs, putting
  them back together in order.
- *Step 4:* Continue to merge the pairs together, with each subset
  being sorted in order.
- *Step 5:* Once all subsets have been combined, the list should be in
  the correct order.
#+BEGIN_HTML
<br>
#+END_HTML
*Merge Sort Algorithm Video*
#+BEGIN_HTML
<iframe width="560" height="315" src="https://www.youtube.com/embed/-v_tAQFUTPw" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe>
#+END_HTML
- *Note:* That if there are an even number of items in the list, for
  example 8 items, the fourth, not the fifth item is taken to be the
  middle item.
#+BEGIN_HTML
<br>
#+END_HTML
*Example 2 - Even List Binary Search*
- Consider the following list of 10 items. We want to find out whether the number =50= is in the list of items.
[[file:img/Bin_Even1.png]]
- *Step 1:* The fifth number in the list is taken to be the middle number - we can therefore discard all data items less than or equal to 37.
[[file:img/Bin_Even2.png]]
- *Step 2:* The third number in the list is now the middle number - we can therefore discard all data items less than or equal to 43.
[[file:img/Bin_Even3.png]]
- *Step 3:* As there are now only two numbers left in the list, when split 48 becomes the middle number. Once we discard 48 we are left with the number =50=.
#+BEGIN_SRC
In an even list, the number left of the central split is taken to be the middle number.
#+END_SRC
#+BEGIN_HTML
<br>
#+END_HTML
*Here is an algorithm for a Binary Search*

[[file:img/Binary_Algor.png]]


* Comparing Linear and Binary Searching Algorithms
:PROPERTIES:
:HTML_CONTAINER_CLASS: activity
:END:
** Learn It: Pro's and Con's of each search?
:PROPERTIES:
:HTML_CONTAINER_CLASS: learn
:END:
*Linear Vs Binary Search Algorithms*
|          *Linear Search*         |          *Binary Search*          |
|----------------------------------+-----------------------------------|
| + Works with unsorted lists      | + Far more efficient              |
|----------------------------------+-----------------------------------|
| - Slower than a binary search    | - Will not work on unsorted lists |
|----------------------------------+-----------------------------------|

#+BEGIN_SRC
The linear search algorithm is fine for small lists, but very inefficient for large lists.
The average time taken to search a thoussand items would be 100 times longer than the time
taken to search 10 items.
If you had to search a database of 10 million car registrations to find who owns a certain
car, it would take a very long time.
#+END_SRC
#+BEGIN_SRC
In contrast, the binary search algorithm is extremely efficient. Each time an item is
examined, if it is not the correct item, half of the list is discarded.
In a list of 10 million items, only 24 items would need to be examined. That's because
10,000,000 is less than 2^24.
In general, if there are fewer than 2^n items (but at least 2^n-1), the maximum number
of items to be examined is n.
#+END_SRC
#+BEGIN_SRC
A key benefit of the linear search is that it can be done on an unsorted list - The items
do not have to be in sequence.
If items are frequently added or deleted from a list, this would save the extra work
needed to keep the list in sequence in order to perform a binary search.
#+END_SRC

** Badge It: Exam Questions
:PROPERTIES:
:HTML_CONTAINER_CLASS: badge
:END:

*Gold*: Answer the following questions:
1. A programmer wants to implement a search algorithm to be used with
   small lists [4,6,8,12,15,16,21].
 - Explain how a linear search would search for the integer '15'.
2. What property of this list [4,6,8,12,15,21], means the programmer
   could use a binary search algorithm?
3. The programmer knows that a binary search algorithm is more efficient than a linear search algorithm. 
 - Explain why the efficiency of these two algorithms in not an important factor when
   choosing what algorithm to implement for the list shown above?

- /Upload to Algorithms - Efficiency: Gold on BourneToLearn/

** Badge It: Binary Search Algorithm
:PROPERTIES:
:HTML_CONTAINER_CLASS: badge
:END:

*Platinum*: Look at the Pseudocode for a Binary Search shown in the Trinket
below:
1. Using the Pseudocode, create a Python program function.
2. Add a binary list of fifteen integer numbers and ask the user to input a value to search for.
3. Output a message to say that the value is found or not in the list.

#+BEGIN_HTML
<iframe src="https://trinket.io/embed/python/ee8f475b62" width="100%" height="600" frameborder="0" marginwidth="0" marginheight="0" allowfullscreen></iframe>
#+END_HTML

- /Upload to Algorithms - Searching Algorithms: Platinum on BourneToLearn/



